RAM
Variables are stored in random access memory (RAM). We sometimes call RAM "working memory" or just "memory."
Think of RAM like a really tall bookcase with a lot of shelves. Like, billions of shelves.
We call a shelf's number its address.
Each shelf holds 8 bits. A bit is a tiny electrical switch that can be turned "on" or "off." But instead of calling it "on" or "off" we call it 1 or 0.
8 bits is called a byte. So each shelf has one byte (8 bits) of storage.
Processor does all the work
Processor is connected to memory controller that has direct assess to the RAM
That direct connection is important. It means we can access address 0 and then immediately access address 918,873 without having to "climb down" our massive bookshelf of RAM.
That's why we call it Random Access Memory (RAM)—we can Access the bits at any Random address in Memory right away.
Cache Locality
Even though the memory controller can jump between far-apart memory addresses quickly, programs tend to access memory that's nearby. So computers are tuned to get an extra speed boost when reading memory addresses that're close to each other
The processor has a cache where it stores a copy of stuff it's recently read from RAM.
This cache is much faster to read from than RAM, so the processor saves time whenever it can read something from cache instead of going out to RAM.
When the processor asks for the contents of a given memory address, the memory controller also sends the contents of a handful of nearby memory addresses. And the processor puts all of it in the cache.
So if the processor asks for the contents of address 951, then 952, then 953, then 954...it'll go out to RAM once for that first read, and the subsequent reads will come straight from the super-fast cache.
But if the processor asks to read address 951, then address 362, then address 419...then the cache won't help, and it'll have to go all the way out to RAM for each read.

Binary Numbers
The number system we usually use (the one you probably learned in elementary school) is called base 10, because each digit has ten possible values (1, 2, 3, 4, 5, 6, 7, 8, 9, and 0).
But computers don't have digits with ten possible values. They have bits with two possible values. So they use base 2 numbers.
Base 10 is also called decimal. Base 2 is also called binary.
Notice how the places in base 10 (ones place, tens place, hundreds place, etc.) are sequential powers of 10:
10^0==1
10^1==10
10^2==100
10^3==1000
etc.
The places in binary (base 2) are sequential powers of 2:
2^0==1
2^1==2
2^2==4
2^3==8
etc.
So far we've been talking about unsigned integers ("unsigned" means non-negative, and "integer" means a whole number, not a fraction or decimal)
Fractions: Store two numbers: the numerator and the denominator.
Decimals: Also two numbers: 1) the number with the decimal point taken out, and 2) the position where the decimal point goes (how many digits over from the leftmost digit).
Negative Numbers: Reserve the leftmost bit for expressing the sign of the number. 0 for positive and 1 for negative
base 16, also called hexadecimal or hex.
In hex, our possible values for each digit are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, and f. Hex numbers are often prefixed with "0x" or "#".
In CSS, colors are sometimes expressed in hex. Interview Cake's signature blue color is "#5bc0de".

Fixed-width Integers
How many different numbers can we express with 1 byte (8 bits)?
2^8==256 different numbers. How did we know to take 2^8?
What happens if we have the number 255 in an 8-bit unsigned integer (1111 1111 in binary) and we add 1? The answer (256) needs a 9th bit (1 0000 0000). But we only have 8 bits!
This is called an integer overflow. At best, we might just get an error. At worst, our computer might compute the correct answer but then just throw out the 9th bit, giving us zero (0000 0000) instead of 256 (1 0000 0000)! (Javascript automatically converts the result to Infinity if it gets too big.)
The 256 possibilities we get with 1 byte are pretty limiting. So we usually use 4 or 8 bytes (32 or 64 bits) for storing integers.
32-bit integers have 2^32 possible values—more than 4 billion
64-bit integers have 2^64 possible values—more than 10 billion billion (10^19)
Ever created a table in SQL? When you specify that a column will hold integers, you have to specify how many bytes: 1 byte (tinyint), 2 bytes (smallint), 4 bytes (int), or 8 bytes (bigint).
Most integers are fixed-width or fixed-length, which means the number of bits they take up doesn't change.